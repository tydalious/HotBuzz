Disassembly Listing for FP3
Generated From:
C:/Users/td1486/MPLABXProjects/FP3.X/dist/default/debug/FP3.X.debug.elf
Jan 22, 2014 12:12:44 PM

---  C:/Users/td1486/MPLABXProjects/FP3.X/main.c  -------------------------------------------------------
1:                 /* 
2:                  * File:   main.c
3:                  * Author: td1486
4:                  *
5:                  * Created on January 9, 2014, 12:52 PM
6:                  */
7:                 #include <p24fxxxx.h>
8:                 #include <adc.h>
9:                 #include <uart.h>
10:                
11:                // FBS
12:                #pragma config BWRP = OFF               // Boot Segment Write Protect (Disabled)
13:                #pragma config BSS = OFF                // Boot segment Protect (No boot flash segment)
14:                
15:                // FGS
16:                #pragma config GWRP = OFF               // General Segment Flash Write Protect (General segment may be written)
17:                #pragma config GSS0 = OFF               // General Segment Code Protect (No Protection)
18:                
19:                // FOSCSEL
20:                #pragma config FNOSC = FRC              // Oscillator Select (Fast RC Oscillator (FRC))
21:                #pragma config SOSCSRC = ANA            // SOSC Source Type (Analog Mode for use with crystal)
22:                #pragma config LPRCSEL = HP             // LPRC Power and Accuracy (High Power/High Accuracy)
23:                #pragma config IESO = OFF               // Internal External Switch Over bit (Internal External Switchover mode disabled (Two-speed Start-up disabled))
24:                
25:                // FOSC
26:                #pragma config POSCMD = NONE            // Primary Oscillator Mode (Primary oscillator disabled)
27:                #pragma config OSCIOFNC = OFF           // CLKO Pin I/O Function (CLKO output signal enabled)
28:                #pragma config POSCFREQ = HS            // Primary Oscillator Frequency Range (Primary Oscillator/External Clock frequency >8MHz)
29:                #pragma config SOSCSEL = SOSCHP         // SOSC Power Selection Configuration bits (Secondary Oscillator configured for high-power operation)
30:                #pragma config FCKSM = CSECME           // Clock Switching and Monitor Selection (Clock Switching and Fail-safe Clock Monitor Enabled)
31:                
32:                // FWDT
33:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscale Select bits (1:32768)
34:                #pragma config FWPSA = PR128            // WDT Prescaler bit (WDT prescaler ratio of 1:128)
35:                #pragma config FWDTEN = SWON            // Watchdog Timer Enable bits (WDT controlled with SWDTEN bit setting)
36:                #pragma config WINDIS = OFF             // Windowed Watchdog Timer Disable bit (Standard WDT selected (windowed WDT disabled))
37:                
38:                // FPOR
39:                #pragma config BOREN = BOR3             // Brown-out Reset Enable bits (Enabled in hardware; SBOREN bit disabled)
40:                #pragma config PWRTEN = ON              // Power-up Timer Enable (PWRT enabled)
41:                #pragma config I2C1SEL = PRI            // Alternate I2C1 Pin Mapping bit (Default SCL1/SDA1 Pins for I2C1)
42:                #pragma config BORV = V18               // Brown-out Reset Voltage bits (Brown-out Reset at 1.8V)
43:                #pragma config MCLRE = ON               // MCLR Pin Enable bit (RA5 input disabled; MCLR enabled)
44:                
45:                // FICD
46:                #pragma config ICS = PGx3               // ICD Pin Placement Select (EMUC/EMUD share PGC3/PGD3)
47:                
48:                unsigned int ADCResult[16],DataAvailable=0;
49:                unsigned char Rxdata[10];
50:                unsigned char DataAvail=0;
51:                unsigned char Txdata[] = "UART Enabled...";
52:                int showAvgValues = 0;
53:                int threshold = 0x50;
54:                
55:                void printC(unsigned char str);
56:                void initUART();
57:                void checkRXbuff();
58:                ////*************** Interrupt Service routine for UART1 Transmission *************************************
59:                //void __attribute__ ((interrupt,no_auto_psv)) _U1TXInterrupt(void)
60:                //{
61:                //  static unsigned int i=0;
62:                //  U1TX_Clear_Intr_Status_Bit;  	//clear the interrupt status of UART1 TX
63:                //  if(Txdata[i]!='\0')			//check for end of string
64:                //  {
65:                //   while(BusyUART1());			//wait till the UART is busy
66:                //   WriteUART1((unsigned int)Txdata[i++]);//Transmit the data to hyper terminal of computer
67:                //  }
68:                //  else
69:                //  DisableIntU1TX; 	//disable the UART TX interrupt after end of complete transmission
70:                //
71:                //}
72:                
73:                //*************** Interrupt Service routine for UART1 reception *************************************
74:                //void __attribute__ ((interrupt,no_auto_psv)) _U1RXInterrupt(void)
75:                //{
76:                //   static unsigned int j=0;
77:                //   U1RX_Clear_Intr_Status_Bit;  	//clear the interrupt status of UART1 RX
78:                //
79:                //   while(!DataRdyUART1());	//wait for data reception on RX
80:                //   Rxdata[j++] = ReadUART1();	//Read the data from UART buffer
81:                //   if(j == 10)
82:                //   DataAvail=1;		//Set the DataAvailability flag after complete reception
83:                // }
84:                //
85:                ////************************ Interrupt service routine for ADC ***********************************
86:                //void __attribute__((interrupt,no_auto_psv)) _ADC1Interrupt(void)
87:                //{
88:                // static unsigned char j=0;
89:                // ADCResult[j]= ReadADC10(j);	//Read the ADC conversion results to ADCResult variable
90:                // j++;
91:                // ADC1_Clear_Intr_Status_Bit;	//Clear interrupt status bit
92:                // if (j==16) 		//Are 16 samples acquired.
93:                //  {
94:                //   DisableIntADC1;	//If so, disable the ADC
95:                //   DataAvailable=1;	//Set th e data available flag bit to interpret the ADC conversion results
96:                //  }
97:                //}
98:                //
99:                ////
100:               //int main(void)
101:               //{
102:               //    int j;
103:               //    initUART();
104:               //    for(j = 0; j< sizeof(Txdata); j++)
105:               //    {
106:               //        if(Txdata[j] == '\0') break;
107:               //        printC(Txdata[j]);
108:               //    }
109:               ////
110:               ////    while(1);
111:               //    TRISB = 0;
112:               //    TRISBbits.TRISB0 = 1;
113:               //    unsigned char i;
114:               //    unsigned int channel;
115:               //
116:               //    while(1)
117:               //    {
118:               //        checkRXbuff();
119:               //        CloseADC10();	//Turn off ADC in case if it was operational previously
120:               //
121:               ////        unsigned char test[] = "test";
122:               ////        printS(test);
123:               //        /************** ADC configuration **********************************
124:               //        *
125:               //        *	Use AN2 channel for siganl sampling
126:               //        *	ADC uses internal RC as source of clock
127:               //        *	Auto scan is enabled
128:               //        *	conversion clcok is selected to 254Tcy
129:               //        *	Sampling interval is selected to 17 TAD
130:               //        *	ADC interrupt after 16 conversions
131:               //        *********************************************************************/
132:               //        channel= ADC_CH0_POS_SAMPLEA_AN2;		//use AN2 for signal sampling
133:               //        AD1CHSbits.CH0SA2 = 0b1;
134:               //        //config1 = ADC_MODULE_OFF | ADC_CLK_AUTO | ADC_AUTO_SAMPLING_ON ;
135:               //        AD1CON1bits.SSRC = 0b111; //ADC_CLK_AUTO - Internal counter ends sampling and starts conversion
136:               //        AD1CON1bits.ASAM = 0b1; //ADC_AUTO_SAMPLING_ON
137:               //        //config2 = ADC_SCAN_ON | ADC_INTR_16_CONV ;
138:               //        AD1CON2bits.CSCNA = 0b1;
139:               //        AD1CON2bits.SMPI = 0b1111;
140:               //        //config3 = ADC_SAMPLE_TIME_17 | ADC_CONV_CLK_254Tcy;
141:               //        AD1CON3bits.SAMC = 0b10001;
142:               //        AD1CON3bits.ADCS = 0b11111;
143:               //        //configportl = 0x0000;
144:               //        //configscanl = ADC_SCAN_AN2 ;
145:               //        AD1CSSLbits.CSSL2 = 0b1;
146:               //       // OpenADC10(config1,config2,config3,configportl,configporth,configscanl,configscanh);
147:               //        ConfigIntADC10(ADC_INT_ENABLE|ADC_INT_PRI_3); 	//configure ADC interrupt
148:               //
149:               //        EnableADC1;    			//turn on the ADC
150:               //        SetChanADC10(channel);    		//Set the channel to AN5
151:               //        while(!DataAvailable);			//wait till the data becomes avaialble
152:               //        DataAvailable=0;    		//clear the Data available flag bit
153:               //
154:               //        int average = 0;
155:               //        int sum = 0;
156:               //        i = 0;
157:               //        while(i <10 )
158:               //        {
159:               //            EnableADC1;     		// Turn on the A/D converter
160:               //        while(BusyADC10());
161:               //            DisableADC1;    		// Turnoff the A/D converter
162:               //            ADCResult[1] = ReadADC10(1);//Read the conversion results from buffer to ADCResults
163:               //            sum = sum + ADCResult[1];
164:               //            i++;
165:               //        }
166:               //        average = sum / 10;
167:               //        int adjValue;
168:               //        if(average < 0x0028)
169:               //        {
170:               //            adjValue = 0;
171:               //        }
172:               //        else if(average >= 0x0028 && average < 0x003A)
173:               //        {
174:               //            adjValue = 1;
175:               //        }
176:               //        else if(average >= 0x003A && average < 0x0043)
177:               //        {
178:               //            adjValue = 2;
179:               //        }
180:               //        else if(average >= 0x0043 && average < 0x0050)
181:               //        {
182:               //            adjValue = 3;
183:               //        }
184:               //        else if(average >= 0x0050 && average < 0x005C)
185:               //        {
186:               //            adjValue = 4;
187:               //        }
188:               //        else if(average >= 0x005C && average < 0x0066)
189:               //        {
190:               //            adjValue = 5;
191:               //        }
192:               //        else if(average >= 0x0066 && average < 0x0071)
193:               //        {
194:               //            adjValue = 6;
195:               //        }
196:               //        else if(average >= 0x0071 && average < 0x007F)
197:               //        {
198:               //            adjValue = 7;
199:               //        }
200:               //        else if(average >= 0x007F)
201:               //        {
202:               //            adjValue = 8;
203:               //        }
204:               //
205:               //
206:               //        if(!showAvgValues)
207:               //        {
208:               //            while(!U1STAbits.TRMT);
209:               //            WriteUART1('\n');
210:               //            while(!U1STAbits.TRMT);
211:               //            WriteUART1('\r');
212:               //            while(!U1STAbits.TRMT);
213:               //            WriteUART1(':');
214:               //            while(!U1STAbits.TRMT);
215:               //            WriteUART1(adjValue+48);
216:               //        }
217:               //        if(adjValue > 4)
218:               //        {
219:               //            //power on
220:               //            PORTBbits.RB1 = 1;
221:               //        }
222:               //        else
223:               //        {
224:               //            //power off
225:               //            PORTBbits.RB1 = 0;
226:               //        }
227:               //
228:               //       CloseADC10(); 		//Close the ADC modue
229:               //    }//end of program
230:               //}
231:               ////
232:               //void printC(unsigned char str)
233:               //{
234:               //    while(!U1STAbits.TRMT);
235:               //    WriteUART1(str);
236:               //}
237:               ////
238:               //void checkRXbuff()
239:               //{
240:               //    int i;
241:               //    for(i = 0; i < sizeof(Rxdata); i++)
242:               //    {
243:               //        if(Rxdata[i] == 'x') break;
244:               //
245:               //        if(Rxdata[i] == 's' && Rxdata[i+1] == 'h' && Rxdata[i+2] == 'y')
246:               //        {
247:               //            showAvgValues = 1;
248:               //        }
249:               //
250:               //        if(Rxdata[i] == 's' && Rxdata[i+1] == 'h' && Rxdata[i+2] == 'n')
251:               //        {
252:               //            showAvgValues = 0;
253:               //        }
254:               //
255:               //        if(Rxdata[i] == 's' && Rxdata[i+1] == 'h' && Rxdata[i+2] == 't')
256:               //        {
257:               //            while(!U1STAbits.TRMT);
258:               //            WriteUART1('\n');
259:               //            WriteUART1(':');
260:               //            WriteUART1(threshold);
261:               //        }
262:               //
263:               //        if(Rxdata[i] == 'c' && Rxdata[i+1] == 'h' && Rxdata[i+2] == 't')
264:               //        {
265:               //            showAvgValues = 0;
266:               //        }
267:               //    }
268:               //}
269:               //
270:               void initUART( )
271:               {
0002F6  FA0000     LNK #0x0
272:                   U1STA = 0;
0002F8  EB0200     CLR W4
0002FA  881114     MOV W4, U1STA
273:                   
274:               //    TRISB = 0;
275:                   TRISBbits.TRISB2 = 1;
0002FC  A842C8     BSET TRISB, #2
276:               //    ConfigIntUART2(UART_RX_INT_EN |UART_RX_INT_PR6);
277:                   OpenUART1(UART_EN | UART_IDLE_CON | UART_IrDA_DISABLE | UART_MODE_SIMPLEX | UART_UEN_00 |
0002FE  200672     MOV #0x67, W2
000300  2EFFF1     MOV #0xEFFF, W1
000302  EB8000     SETM W0
000304  07FFC9     RCALL _OpenUART1
278:                           UART_EN_WAKE | UART_DIS_LOOPBACK | UART_DIS_ABAUD |
279:                           UART_NO_PAR_8BIT | UART_BRGH_FOUR | UART_1STOPBIT,
280:                           UART_TX_ENABLE , 103);
281:               
282:                   U1STA = 0;
000306  EB0200     CLR W4
000308  881114     MOV W4, U1STA
283:                   U1MODE = 0x8000;
00030A  280004     MOV #0x8000, W4
00030C  881104     MOV W4, U1MODE
284:               //    U1MODEbits.UEN = 0x00;
285:               //    U1MODEbits.PDSEL = 0x00;
286:               //    U1MODEbits.STSEL = 0;
287:               //    U1MODEbits.LPBACK = 0;
288:                   
289:                   U1STAbits.UTXEN = 1;
00030E  A84223     BSET 0x223, #2
290:                   TRISBbits.TRISB7 = 0;
000310  A9E2C8     BCLR TRISB, #7
291:                   TRISBbits.TRISB2 = 1;
000312  A842C8     BSET TRISB, #2
292:               //    IFS0bits.U1RXIF = 1;
293:               
294:               }
000314  FA8000     ULNK
000316  060000     RETURN
295:               
296:               int main()
297:               {
000318  FA0002     LNK #0x2
298:                   initUART();
00031A  07FFED     RCALL initUART
299:                   unsigned char ch;
300:               
301:                   while(1)
302:                   {
303:                       while(U1STAbits.UTXBF);
00031C  000000     NOP
00031E  801115     MOV U1STA, W5
000320  202004     MOV #0x200, W4
000322  628204     AND W5, W4, W4
000324  520FE0     SUB W4, #0x0, [W15]
000326  3AFFFB     BRA NZ, 0x31E
00033E  37FFEF     BRA 0x31E
304:                       U1MODEbits.LPBACK = 1;
000328  A8C220     BSET U1MODE, #6
305:                       WriteUART1('k');
00032A  2006B0     MOV #0x6B, W0
00032C  07FFD6     RCALL _WriteUART1
306:                       
307:                       
308:                       if (U1STAbits.URXDA)
00032E  801114     MOV U1STA, W4
000330  620261     AND W4, #0x1, W4
000332  520FE0     SUB W4, #0x0, [W15]
000334  320003     BRA Z, 0x33C
309:                           ch = ReadUART1();
000336  07FFC4     RCALL _ReadUART1
000338  780200     MOV W0, W4
00033A  784F04     MOV.B W4, [W14]
310:                    }
00033C  000000     NOP
311:               }
